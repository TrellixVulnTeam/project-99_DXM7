{"ast":null,"code":"import \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport ScrollSpy from './scrollspy.class';\nimport { isBrowser } from '../../utils/env';\nimport { keys } from '../../utils/object';\nimport { isNumber, isObject, isString } from '../../utils/inspect'; // Key we use to store our instance\n\nvar BV_SCROLLSPY = '__BV_ScrollSpy__'; // Build a ScrollSpy config based on bindings (if any)\n// Arguments and modifiers take precedence over passed value config object\n\n/* istanbul ignore next: not easy to test */\n\nvar parseBindings = function parseBindings(bindings)\n/* istanbul ignore next: not easy to test */\n{\n  var config = {}; // If argument, assume element ID\n\n  if (bindings.arg) {\n    // Element ID specified as arg\n    // We must prepend '#' to become a CSS selector\n    config.element = \"#\".concat(bindings.arg);\n  } // Process modifiers\n\n\n  keys(bindings.modifiers).forEach(function (mod) {\n    if (/^\\d+$/.test(mod)) {\n      // Offset value\n      config.offset = parseInt(mod, 10);\n    } else if (/^(auto|position|offset)$/.test(mod)) {\n      // Offset method\n      config.method = mod;\n    }\n  }); // Process value\n\n  if (isString(bindings.value)) {\n    // Value is a CSS ID or selector\n    config.element = bindings.value;\n  } else if (isNumber(bindings.value)) {\n    // Value is offset\n    config.offset = Math.round(bindings.value);\n  } else if (isObject(bindings.value)) {\n    // Value is config object\n    // Filter the object based on our supported config options\n    keys(bindings.value).filter(function (k) {\n      return Boolean(ScrollSpy.DefaultType[k]);\n    }).forEach(function (k) {\n      config[k] = bindings.value[k];\n    });\n  }\n\n  return config;\n}; // Add or update ScrollSpy on our element\n\n\nvar applyScrollspy = function applyScrollspy(el, bindings, vnode)\n/* istanbul ignore next: not easy to test */\n{\n  if (!isBrowser) {\n    /* istanbul ignore next */\n    return;\n  }\n\n  var config = parseBindings(bindings);\n\n  if (el[BV_SCROLLSPY]) {\n    el[BV_SCROLLSPY].updateConfig(config, vnode.context.$root);\n  } else {\n    el[BV_SCROLLSPY] = new ScrollSpy(el, config, vnode.context.$root);\n  }\n}; // Remove ScrollSpy on our element\n\n/* istanbul ignore next: not easy to test */\n\n\nvar removeScrollspy = function removeScrollspy(el)\n/* istanbul ignore next: not easy to test */\n{\n  if (el[BV_SCROLLSPY]) {\n    el[BV_SCROLLSPY].dispose();\n    el[BV_SCROLLSPY] = null;\n    delete el[BV_SCROLLSPY];\n  }\n};\n/*\n * Export our directive\n */\n\n\nexport var VBScrollspy = {\n  bind: function bind(el, bindings, vnode)\n  /* istanbul ignore next: not easy to test */\n  {\n    applyScrollspy(el, bindings, vnode);\n  },\n  inserted: function inserted(el, bindings, vnode)\n  /* istanbul ignore next: not easy to test */\n  {\n    applyScrollspy(el, bindings, vnode);\n  },\n  update: function update(el, bindings, vnode)\n  /* istanbul ignore next: not easy to test */\n  {\n    if (bindings.value !== bindings.oldValue) {\n      applyScrollspy(el, bindings, vnode);\n    }\n  },\n  componentUpdated: function componentUpdated(el, bindings, vnode)\n  /* istanbul ignore next: not easy to test */\n  {\n    if (bindings.value !== bindings.oldValue) {\n      applyScrollspy(el, bindings, vnode);\n    }\n  },\n  unbind: function unbind(el)\n  /* istanbul ignore next: not easy to test */\n  {\n    removeScrollspy(el);\n  }\n};\nexport default VBScrollspy;","map":{"version":3,"sources":["D:/UEK/project-99/node_modules/bootstrap-vue/esm/directives/scrollspy/scrollspy.js"],"names":["ScrollSpy","isBrowser","keys","isNumber","isObject","isString","BV_SCROLLSPY","parseBindings","bindings","config","arg","element","concat","modifiers","forEach","mod","test","offset","parseInt","method","value","Math","round","filter","k","Boolean","DefaultType","applyScrollspy","el","vnode","updateConfig","context","$root","removeScrollspy","dispose","VBScrollspy","bind","inserted","update","oldValue","componentUpdated","unbind"],"mappings":"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","sourcesContent":["import ScrollSpy from './scrollspy.class';\nimport { isBrowser } from '../../utils/env';\nimport { keys } from '../../utils/object';\nimport { isNumber, isObject, isString } from '../../utils/inspect'; // Key we use to store our instance\n\nvar BV_SCROLLSPY = '__BV_ScrollSpy__'; // Build a ScrollSpy config based on bindings (if any)\n// Arguments and modifiers take precedence over passed value config object\n\n/* istanbul ignore next: not easy to test */\n\nvar parseBindings = function parseBindings(bindings)\n/* istanbul ignore next: not easy to test */\n{\n  var config = {}; // If argument, assume element ID\n\n  if (bindings.arg) {\n    // Element ID specified as arg\n    // We must prepend '#' to become a CSS selector\n    config.element = \"#\".concat(bindings.arg);\n  } // Process modifiers\n\n\n  keys(bindings.modifiers).forEach(function (mod) {\n    if (/^\\d+$/.test(mod)) {\n      // Offset value\n      config.offset = parseInt(mod, 10);\n    } else if (/^(auto|position|offset)$/.test(mod)) {\n      // Offset method\n      config.method = mod;\n    }\n  }); // Process value\n\n  if (isString(bindings.value)) {\n    // Value is a CSS ID or selector\n    config.element = bindings.value;\n  } else if (isNumber(bindings.value)) {\n    // Value is offset\n    config.offset = Math.round(bindings.value);\n  } else if (isObject(bindings.value)) {\n    // Value is config object\n    // Filter the object based on our supported config options\n    keys(bindings.value).filter(function (k) {\n      return Boolean(ScrollSpy.DefaultType[k]);\n    }).forEach(function (k) {\n      config[k] = bindings.value[k];\n    });\n  }\n\n  return config;\n}; // Add or update ScrollSpy on our element\n\n\nvar applyScrollspy = function applyScrollspy(el, bindings, vnode)\n/* istanbul ignore next: not easy to test */\n{\n  if (!isBrowser) {\n    /* istanbul ignore next */\n    return;\n  }\n\n  var config = parseBindings(bindings);\n\n  if (el[BV_SCROLLSPY]) {\n    el[BV_SCROLLSPY].updateConfig(config, vnode.context.$root);\n  } else {\n    el[BV_SCROLLSPY] = new ScrollSpy(el, config, vnode.context.$root);\n  }\n}; // Remove ScrollSpy on our element\n\n/* istanbul ignore next: not easy to test */\n\n\nvar removeScrollspy = function removeScrollspy(el)\n/* istanbul ignore next: not easy to test */\n{\n  if (el[BV_SCROLLSPY]) {\n    el[BV_SCROLLSPY].dispose();\n    el[BV_SCROLLSPY] = null;\n    delete el[BV_SCROLLSPY];\n  }\n};\n/*\n * Export our directive\n */\n\n\nexport var VBScrollspy = {\n  bind: function bind(el, bindings, vnode)\n  /* istanbul ignore next: not easy to test */\n  {\n    applyScrollspy(el, bindings, vnode);\n  },\n  inserted: function inserted(el, bindings, vnode)\n  /* istanbul ignore next: not easy to test */\n  {\n    applyScrollspy(el, bindings, vnode);\n  },\n  update: function update(el, bindings, vnode)\n  /* istanbul ignore next: not easy to test */\n  {\n    if (bindings.value !== bindings.oldValue) {\n      applyScrollspy(el, bindings, vnode);\n    }\n  },\n  componentUpdated: function componentUpdated(el, bindings, vnode)\n  /* istanbul ignore next: not easy to test */\n  {\n    if (bindings.value !== bindings.oldValue) {\n      applyScrollspy(el, bindings, vnode);\n    }\n  },\n  unbind: function unbind(el)\n  /* istanbul ignore next: not easy to test */\n  {\n    removeScrollspy(el);\n  }\n};\nexport default VBScrollspy;"]},"metadata":{},"sourceType":"module"}